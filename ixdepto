#!/usr/bin/perl
use AppMercado;

#INFO: informe por depto, con resumen por piso y por edificio

@SUMAR_COLS=qw/METROS_TOTALES METROS_CUBIERTOS/;
@PROMEDIAR_COLS=qw/USDxM2 USDxM2Cubierto/;

logm("DBG",9,"Comienzo de reporte",);

#*outfmt= \&outfmtFicha;

*outfmt= \&outfmtHtmlTable;
#XXX: agregar las cols que faltan
$single_table_cols=[qw/K NOMBRE PISO METROS_CUBIERTOS METROS_TOTALES USDxM2Cubierto USDxM2/];
$HTML_COLS{DEPTO}=$single_table_cols;
$HTML_COLS{EDIFICIO}= $single_table_cols;
$HTML_COLS{PISO}= $single_table_cols;

out("<table>\n");

$edificioCur='';
$pisoCur='';
my %tote=();
my %totp= (); 
dbFindFold('T="deptos" AND TIPO="DEPARTAMENTO"',{},['nombre','piso'],sub { my ($r)= @_;
	my $d= $r->{DEPTOS};
	#DBG: ficha 
	if ($edificioCur ne $d->{NOMBRE}) {
		if ($tote{CNT}) { #A: hay deptos
			foreach my $c (@PROMEDIAR_COLS) { $tote{$c}= $tote{$c}/$tote{CNT}; }
			$tote{NOMBRE}= $edificioCur; 
			$tote{K}="RESUMEN EDIFICIO " . $edificioCur;
			outfmt("EDIFICIO",\%tote);	
		}
		$edificioCur= $d->{NOMBRE};
		$pisoCur= $d->{PISO};
		%tote=();
		%totp=();
	}
	elsif ($pisoCur ne $d->{PISO}) {
		if ($totp{CNT}) { #A: hay deptos
			foreach my $c (@PROMEDIAR_COLS) { $totp{$c}= $totp{$c}/$totp{CNT}; }
			$totp{NOMBRE}= $edificioCur; $totp{PISO}= $pisoCur;
			$totp{K}="RESUMEN PISO " . $pisoCur . "/" .$edificioCur;
			outfmt("PISO",\%totp);	
		}
		$pisoCur= $d->{PISO};
		%totp=();
	}
	$d->{VALOR}=~ s/\D//g;
	$d->{METROS_TOTALES}||= $d->{METROS_CUBIERTOS};
	#XXX: hacer esto ANTES de meterlo en la base!
	#A: normalizados	
	$d->{USDxM2}= $d->{VALOR} / ($d->{METROS_TOTALES}||1);
	$d->{USDxM2Cubierto}= $d->{VALOR} / ($d->{METROS_CUBIERTOS}||1);
	#A: derivados
	$tote{CNT}++; $totp{CNT}++;
	foreach my $c (@PROMEDIAR_COLS, @SUMAR_COLS) {
		$tote{$c}+= $d->{$c};
		$totp{$c}+= $d->{$c};
	}
	outfmt("DEPTO",$d);	
});
#XXX: out del resumen para el ultimo piso y ultimo edificio!

out("\n</table>\n");

#S: template
open(IN,"<template.html"); $TPL= join("",<IN>); close(IN);
$html= $TPL; $html=~ s/\<\%=\s*OUT\s*\%\>/$OUT/;
print $html;

#S: formato
sub	outfmtFicha {
	my ($type, $kv)= @_;
	out(join("",map("$_:\t$kv->{$_}\n",sort(keys(%$kv)))) . ("-" x 75) . "\n");
} 

sub	outfmtHtmlTable {
	my ($type, $kv)= @_;
	$HTML_COLS{$type}||= [keys(%$kv)];
	out("<tr>" . join("",map("<td>$kv->{$_}</td>", @{$HTML_COLS{$type}})) . "</tr>\n");
}

#S: out en vez de print
#DFTL: sub out { print join("", @_); }
#DFLT: sub outf { printf(@_); }
sub out { $OUT.= join("", @_); }
sub outf { my ($fmt, @args)= @_; $OUT.= sprintf($fmt,@args); }
